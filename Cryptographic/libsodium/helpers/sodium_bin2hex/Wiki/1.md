
---

### Function signature

```c
char *sodium_bin2hex(char *const hex, const size_t hex_maxlen,
                     const unsigned char *const bin, const size_t bin_len)
```

* `hex`: output buffer where the hex string will be stored.
* `hex_maxlen`: size of that buffer (must be big enough).
* `bin`: input binary data.
* `bin_len`: number of bytes in `bin`.

The function returns the same `hex` pointer (C-style "builder" function).

---

### Safety check

```c
if (bin_len >= SIZE_MAX / 2 || hex_maxlen <= bin_len * 2U) {
    sodium_misuse();
}
```

* Each byte of binary turns into **two hex characters**.
* So output buffer needs to hold `bin_len * 2 + 1` (the `+1` is for `'\0'`).
* This check ensures no integer overflow and that the output buffer is large enough.

---

### The main loop

```c
while (i < bin_len) {
    c = bin[i] & 0xf;       // low 4 bits (nibble)
    b = bin[i] >> 4;        // high 4 bits (nibble)
```

Example: if `bin[i] = 0xAB`

* `b = 0xA` (10 decimal)
* `c = 0xB` (11 decimal)

---

### Converting nibble to ASCII hex

```c
x = (unsigned char)(87U + c + (((c - 10U) >> 8) & ~38U)) << 8 |
    (unsigned char)(87U + b + (((b - 10U) >> 8) & ~38U));
```

This is the **trickiest part**. It avoids branches (`if`) by using bit-magic.

Normal hex conversion:

* if nibble < 10 → `'0' + nibble`
* else           → `'a' + (nibble - 10)`

This code does the same, but branch-free (important for performance and avoiding side-channel leaks).

Let’s decode:

* Start with `87U + nibble`.

  * If nibble < 10, adjust with `(((nibble - 10U) >> 8) & ~38U)` so result becomes `'0' + nibble`.
  * If nibble ≥ 10, adjustment makes it `'a' + (nibble - 10)`.

So result is correct hex ASCII.

Then it packs two ASCII characters (for `c` and `b`) into one integer `x`:

* High byte = low nibble’s char (`c`)
* Low byte = high nibble’s char (`b`)

---

### Writing into output buffer

```c
hex[i * 2U] = (char) x;       // store low byte (high nibble)
x >>= 8;
hex[i * 2U + 1U] = (char) x;  // store high byte (low nibble)
i++;
```

Notice the **order**:

* `hex[i*2]` = high nibble char
* `hex[i*2+1]` = low nibble char

So `0xAB` → `"ab"` in ASCII.

---

### Null terminator

```c
hex[i * 2U] = 0U;
```

Adds `'\0'` at the end (C string terminator).

---

### Return

```c
return hex;
```

---

### Example walkthrough

Input: `bin = { 0xAB, 0x3F }`

* Byte `0xAB`: `b=0xA (10) → 'a'`, `c=0xB (11) → 'b'` → `"ab"`
* Byte `0x3F`: `b=3 → '3'`, `c=0xF (15) → 'f'` → `"3f"`
  Final string: `"ab3f"`

---

✅ **Summary in plain words**:
This function takes binary data and converts it into lowercase hexadecimal string (`0–9`, `a–f`). It carefully avoids branches and integer overflows for safety and speed.


