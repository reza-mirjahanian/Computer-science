

### 1\. One-line summary

Bead Sort is a simple, visual sorting algorithm for **positive integers** that works by mimicking beads falling on an abacus, but it's often too slow and memory-intensive for practical use.

-----

### 2\. Intuition and real-world analogy

Imagine an abacus with vertical rods. For each number in your list, you place that many beads on a corresponding horizontal row. If you then tilt the abacus, the beads fall down the rods due to gravity, naturally arranging themselves to represent the sorted list.  Gravity does the sorting for you\! 😮

-----

### 3\. Formal definition and key properties

Bead Sort is a **natural sorting algorithm**, meaning it models a natural physical process. It operates in a way that is radically different from comparison-based sorts like Bubble Sort or Quicksort.

  * **Constraint:** It can only sort lists of **positive integers**.
  * **Non-comparison:** It doesn't compare elements to each other directly. Instead, it maps each number to a physical representation (a row of beads).
  * **Stability:** Bead sort is a **stable** sort, meaning that if you have duplicate numbers, their original relative order is preserved.

-----

### 4\. Required operations

Bead sort isn't a data structure you'd perform `insert` or `delete` on. It's a one-time process for sorting a whole list. The main "operations" are:

1.  **Setup:** Create a grid (our "abacus") based on the input list.
2.  **Drop:** Let the "beads" fall down the "rods" (columns).
3.  **Readout:** Count the beads in each row to get the final sorted list.

-----

### 5\. Step-by-step algorithm walkthrough

Let's sort the list `[3, 1, 4, 2]`.

#### Step 1: Find the maximum value

First, we find the largest number in the list to know how wide our abacus needs to be.

  * **Explanation:** The maximum number determines how many vertical "rods" (columns) we need.
  * **Example:** For `[3, 1, 4, 2]`, the max value is **4**. We'll need 4 columns.

| Input List | Max Value |
| :--- | :--- |
| `[3, 1, 4, 2]` | `4` |

#### Step 2: Set up the grid (abacus)

Create a grid where each number in the list gets its own row. We place a "bead" (`*`) for each unit of the number.

  * **Explanation:** This is like setting up the abacus before gravity takes effect. The number of rows is the count of numbers in our list (4), and the number of columns is the max value (4).
  * **Example:** For `[3, 1, 4, 2]`:

| Number | Grid Representation (Beads `*`) |
| :--- | :--- |
| 3 | `[*, *, *, .]` |
| 1 | `[*, ., ., .]` |
| 4 | `[*, *, *, *]` |
| 2 | `[*, *, ., .]` |
*Note: `.` represents an empty spot.*

#### Step 3: Let the beads "fall"

Now, simulate gravity. For each column (rod), count how many beads it has and let them drop to the bottom-most available rows in that column.

  * **Explanation:** This is the core "sorting" step. All the beads in a column slide down, filling the lowest rows first.
  * **Example:**
      * **Column 1:** Has 4 beads. They fill the bottom 4 rows.
      * **Column 2:** Has 3 beads. They fill the bottom 3 rows.
      * **Column 3:** Has 2 beads. They fill the bottom 2 rows.
      * **Column 4:** Has 1 bead. It fills the bottom 1 row.

The grid now looks like this:

| "Fallen" Grid |
| :--- |
| `[*, ., ., .]` |
| `[*, *, ., .]` |
| `[*, *, *, .]` |
| `[*, *, *, *]` |

#### Step 4: Read the sorted list

Finally, count the number of beads in each row of the "fallen" grid. This gives you the sorted list\!

  * **Explanation:** The rows now naturally represent the numbers in ascending order from top to bottom.
  * **Example:**
      * **Top row:** 1 bead -\> `1`
      * **Second row:** 2 beads -\> `2`
      * **Third row:** 3 beads -\> `3`
      * **Bottom row:** 4 beads -\> `4`

The final sorted list is `[1, 2, 3, 4]`. ✨

-----

### 6\. Pseudocode

```
function BeadSort(list):
  // 1. Handle edge cases
  if list is empty, return empty list

  // 2. Find the maximum value to determine grid width
  maxValue = max(list)

  // 3. Set up the grid with beads
  grid = create a grid of size (length of list) x (maxValue)
  for each number in list:
    place 'number' beads in its corresponding row in the grid

  // 4. Let beads fall
  for each column in grid:
    count the number of beads in this column (sum_beads)
    clear all beads in this column
    place sum_beads at the bottom of this column

  // 5. Read the result
  sortedList = create an empty list
  for each row in grid:
    count the number of beads in this row
    add this count to sortedList

  return sortedList
```

-----

### 7\. Two runnable implementations (Python)

#### Short, idiomatic version

This version cleverly uses `zip` to transpose the grid, which simulates the beads falling.

```python
def bead_sort_idiomatic(arr: list[int]) -> list[int]:
    """Short, idiomatic implementation of Bead Sort."""
    if not arr or any(n < 0 for n in arr):
        # Bead sort is for positive integers.
        # Returning arr for simplicity, but could raise an error.
        return arr

    max_val = max(arr)
    # Create the grid (abacus)
    grid = [['_'] * max_val for _ in arr]
    for i, num in enumerate(arr):
        for j in range(num):
            grid[i][j] = '*'

    # "Drop" the beads by transposing and re-filling columns
    transposed = list(zip(*grid))
    fallen_grid = []
    for col in transposed:
        bead_count = col.count('*')
        new_col = ['_'] * (len(arr) - bead_count) + ['*'] * bead_count
        fallen_grid.append(new_col)

    # Transpose back and read the result
    final_grid = list(zip(*fallen_grid))
    return [row.count('*') for row in final_grid]

# Example usage
my_list = [3, 1, 4, 2]
print(f"Original: {my_list}")
print(f"Sorted:   {bead_sort_idiomatic(my_list)}")
# Output:
# Original: [3, 1, 4, 2]
# Sorted:   [1, 2, 3, 4]
```

#### Commented version for learners

This version is more verbose and breaks down each step with comments.

```python
def bead_sort_learner(arr: list[int]) -> list[int]:
    """A detailed, commented implementation of Bead Sort for learners."""
    # --- Input Validation ---
    # Bead sort is defined for positive integers.
    # We'll handle empty lists and non-positive numbers gracefully.
    if not arr:
        return []
    if any(num < 0 for num in arr):
        raise ValueError("Bead sort works only with non-negative integers.")

    # --- Step 1: Find grid dimensions ---
    num_count = len(arr)
    max_val = max(arr) if arr else 0

    # --- Step 2: Set up the grid (abacus) ---
    # We create a 2D list (a list of lists) to represent the grid.
    # `True` represents a bead, `False` represents an empty spot.
    grid = [[False] * max_val for _ in range(num_count)]

    # Place the "beads" for each number in its row.
    for row_index, number in enumerate(arr):
        for col_index in range(number):
            grid[row_index][col_index] = True

    # --- Step 3: Let the beads "fall" ---
    # We iterate through each column (vertical rod).
    for col_index in range(max_val):
        # Count how many beads are in this column.
        beads_in_col = 0
        for row_index in range(num_count):
            if grid[row_index][col_index]:
                beads_in_col += 1

        # Now, "drop" them. First, clear the column.
        for row_index in range(num_count):
            grid[row_index][col_index] = False

        # Then, fill the column from the bottom up.
        # The lowest rows get the beads.
        for row_index in range(num_count - beads_in_col, num_count):
            grid[row_index][col_index] = True

    # --- Step 4: Read the sorted list ---
    # Create an empty list to store our results.
    sorted_arr = []
    # Iterate through each row and count the beads.
    for row_index in range(num_count):
        beads_in_row = sum(grid[row_index]) # sum() on bools counts True as 1
        sorted_arr.append(beads_in_row)

    return sorted_arr

# Example usage
my_list = [5, 3, 1, 7, 4, 1, 6, 5]
print(f"Original: {my_list}")
print(f"Sorted:   {bead_sort_learner(my_list)}")
# Output:
# Original: [5, 3, 1, 7, 4, 1, 6, 5]
# Sorted:   [1, 1, 3, 4, 5, 5, 6, 7]
```

-----

### 8\. Complete worked examples

Let's trace the list `[4, 2, 1, 3]`.

#### Textual table of states

| Step | Action | State / Grid Representation | Result |
| :--- | :--- | :--- | :--- |
| 1 | Find Max | `[4, 2, 1, 3]` | `max = 4` |
| 2 | Setup Grid | `[*, *, *, *]`<br>`[*, *, ., .]`<br>`[*, ., ., .]`<br>`[*, *, *, .]` | Grid created. |
| 3 | Drop Beads | **Before:** See above.<br>**After:**<br>`[*, ., ., .]`<br>`[*, *, ., .]`<br>`[*, *, *, .]`<br>`[*, *, *, *]` | Gravity applied. |
| 4 | Readout | `[*, ., ., .]` -\> count is 1<br>`[*, *, ., .]` -\> count is 2<br>`[*, *, *, .]` -\> count is 3<br>`[*, *, *, *]` -\> count is 4 | `[1, 2, 3, 4]` |

#### Mermaid and ASCII diagram

```mermaid
graph TD
    A[Start: [4, 2, 1, 3]] --> B{Step 1: Setup Grid};
    B --> C["
    Grid (Before Gravity):
    4: ****
    2: **..
    1: *...
    3: ***.
    "];
    C --> D{Step 2: Apply Gravity};
    D --> E["
    Grid (After Gravity):
    1: *...
    2: **..
    3: ***.
    4: ****
    "];
    E --> F{Step 3: Read Rows};
    F --> G[Finish: [1, 2, 3, 4]];

    style A fill:#cde4ff
    style G fill:#d5fdd5
```

**ASCII Fallback:**

```
[Start: [4, 2, 1, 3]]
         |
         v
+------------------------+
|  Step 1: Setup Grid    |
|  4: **** |
|  2: **..               |
|  1: *...               |
|  3: ***.               |
+------------------------+
         |
         v
+------------------------+
|  Step 2: Apply Gravity |
|  1: *...               |
|  2: **..               |
|  3: ***.               |
|  4: **** |
+------------------------+
         |
         v
+------------------------+
|   Step 3: Read Rows    |
+------------------------+
         |
         v
  [Finish: [1, 2, 3, 4]]
```

-----

### 9\. Complexity

Let $N$ be the number of elements in the list and $S$ be the value of the largest element.

  * **Time Complexity:** $O(N \\cdot S)$

      * **Why?** The dominant operations are setting up the grid and letting the beads fall. Both require iterating through the grid. The grid has $N$ rows and $S$ columns, so the work is proportional to $N \\times S$. The best, average, and worst cases are all the same because we always have to process the entire grid.
      * *(A note on physical models: If you built a real-life bead sorter, the time would just be how long the beads take to fall, which is almost constant, making it look like $O(1)$\! This is a classic hardware vs. software difference.)*

  * **Space Complexity:** $O(N \\cdot S)$

      * **Why?** We must store the entire $N \\times S$ grid in memory. This is the biggest drawback of Bead Sort, as a single large number can make it require a huge amount of memory. For example, sorting `[1, 1000000]` would be disastrous\!

-----

### 10\. Correctness sketch or invariant

The correctness of Bead Sort relies on a key invariant maintained after the "gravity" step. For any column $j$, the number of beads in that column is equal to the number of elements in the original list that are greater than or equal to $j$. When these beads fall, they stack from the bottom up. Therefore, the $k$-th row from the bottom will contain a bead in column $j$ if and only if there were at least $k$ numbers in the original list with a value of $j$ or more. This directly implies that the number of beads in the $k$-th row from the bottom corresponds to the $k$-th smallest number in the original list.

-----

### 11\. Common pitfalls, edge cases, and variations

  * **Pitfalls:**

      * **Using on non-positive integers:** The algorithm is not designed for negative numbers or decimals.
      * **Large numbers:** Trying to sort a list with a very large number (e.g., `[5, 999999]`) will consume an enormous amount of memory and be very slow.
      * **Confusing physical vs. software complexity:** Don't mistake the near-instant physical analogy for the $O(N \\cdot S)$ performance of a software simulation.

  * **Edge Cases:**

      * **Empty list `[]`:** A good implementation should handle this and return an empty list.
      * **List with zeros `[2, 0, 1]`:** Zeros are handled naturally; they correspond to a row with zero beads.
      * **All same elements `[3, 3, 3]`:** This works perfectly. The grid will be rectangular both before and after the drop.

  * **Variations:**

      * **Descending Sort:** To sort in descending order, you can simply read the resulting grid from bottom-to-top instead of top-to-bottom.

-----

### 12\. Practice problems

#### Easy Problem

Trace the states of Bead Sort for the input list `[2, 5, 2]`. What does the grid look like before and after gravity?

\<details\>
\<summary\>Solution\</summary\>

1.  **Max Value:** 5. The list has 3 numbers. Grid size will be 3 rows x 5 columns.
2.  **Grid Before Gravity:**
    ```
    [*, *, ., ., .]  (for 2)
    [*, *, *, *, *]  (for 5)
    [*, *, ., ., .]  (for 2)
    ```
3.  **Grid After Gravity:**
      * Column 1: 3 beads -\> `[*, *, *]`
      * Column 2: 3 beads -\> `[*, *, *]`
      * Column 3: 1 bead -\> `[., ., *]`
      * Column 4: 1 bead -\> `[., ., *]`
      * Column 5: 1 bead -\> `[., ., *]`
      * Reassembled Grid:
    <!-- end list -->
    ```
    [*, *, ., ., .]
    [*, *, ., ., .]
    [*, *, *, *, *]
    ```
4.  **Final List:** Reading the rows gives `[2, 2, 5]`.

\</details\>

#### Medium Problem

Imagine you're sorting the list `[10, 20]`. In a typical Bead Sort implementation, you'd create a 2x20 grid. How could you optimize the `drop` (gravity) step to avoid iterating through empty columns 11-19, which have no beads?

\<details\>
\<summary\>Solution\</summary\>

Instead of iterating through every column from 1 to `max_val`, you can iterate through the columns *represented by the beads themselves*.

1.  **Setup:** Create the grid as usual:
    ```
    Row for 10: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, ...]
    Row for 20: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ...]
    ```
2.  **Optimized Drop:** Instead of a `for col in 0..max_val`, you can create a `column_sums` array or dictionary of size `max_val`.
    ```python
    # Pseudo-code
    column_sums = [0] * max_val
    for number in list:
        for i in range(number):
            column_sums[i] += 1
    ```
    This directly calculates how many beads *should* be in each column without building the intermediate "fallen" grid column-by-column. Then you can construct the final sorted array from these sums. This avoids the nested loop over the entire grid for the "drop" step, though the complexity remains the same. The core idea is to count first, then reconstruct.

\</details\>

-----

### 13\. Short cheat-sheet and next topics

  * ✅ **Best for:** Small lists of small, positive integers. It's more of a cool theoretical concept than a practical algorithm.
  * 🧠 **Core Idea:** Represents numbers as rows of beads on an abacus and lets "gravity" do the sorting.
  * ❌ **Biggest Weakness:** Very high space and time complexity ($O(N \\cdot S)$), making it unusable for lists with large numbers.
  * ✨ **Key Property:** It is *not* a comparison-based sort.

#### Recommended Next Topics:

  * **Counting Sort:** Another non-comparison integer sorting algorithm. It's much more practical and shares the idea of using array indices to represent values.
  * **Radix Sort:** A clever algorithm that sorts integers digit-by-digit. It builds upon the ideas of non-comparison sorting.